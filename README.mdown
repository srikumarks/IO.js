# IO.js: A library for composeable asynchronous actions #

`IO` is a Javascript library for managing sequencing of asynchronous actions.
This [infoq article] summarizes the state of the art in an interview conducted
with the creators of the existing libraries for managing asynchronous
operations in JS and features interviews with the creators of these libraries -
[Step], [Flow-js], [node-promise], [Async], [Async.js], [FuturesJS] and
[slide-flow-control]. What stands out is that most of them say relatively
little on "error management". Here is also a [Hacker News thread] discussing
Python creator Guido van Rossum's objections to a callback based API, based on
its poor ability to work with exceptions. 

[infoq article]: http://www.infoq.com/articles/surviving-asynchronous-programming-in-javascript
[Hacker News thread]: http://news.ycombinator.com/item?id=3750817
[Step]: https://github.com/creationix/step
[Flow-js]: https://github.com/willconant/flow-js
[node-promise]: https://github.com/kriszyp/node-promise
[Async]: https://github.com/caolan/async
[Async.js]: https://github.com/fjakobs/async.js
[FuturesJS]: https://github.com/coolaj86/futures
[slide-flow-control]: https://github.com/isaacs/slide-flow-control

The focus of `IO`, therefore, is to provide for flexible error management, in
particular --

1. Trapping errors and deciding what to do with them,
2. Recovering from errors and resuming operations,
3. Managing control flow between error handlers,
4. Showing clearly the scope of control of error handlers that are in effect.

... and, of course, do the rest of the stuff that the other libraries do fairly 
well. 

With regard to efficiency, `IO` takes the view that the tasks that you're
executing ought to be much more complex than any overheads `IO` might add.

# Core concepts #

`IO`, at its core, is a library for creating "actions" and "running" them, usually
using `IO.run(input, action)`. 

## Actions ##

An action is a function that does something, possibly asynchronously, and
chooses what to do next based on what it did. Actions are usually created and
composed using the various functions provided by `IO`, but you can write your
own as well. You run an action like this -

    IO.run("some input data", action);

User supplied actions can come in one of four forms. The forms are detected
using the number of arguments that the function has -

1.  Ordinary functions of the form --

        function (input) { return something; }

    These actions succeed by returning a result which is passed along, or fail
    by throwing an exception. You shouldn't be using `IO` if you only have
    actions of this kind. If you want the function to stop the execution, you
    can return `undefined`.

2.  Pure action of the form --

        function (callback, errback) { ... }
        
    This is in the common "callback/errback" style where the callback is a one
    argument function used for continuing with the output of this action and
    errback is a one argument function that starts an error processing
    sequence.

3.  Input processing form --

        function (input, callback, errback) { ... }

    The input flows in at the point the action is executed and `callback` and
    `errback` are as described above. You'll mostly use the previous form and
    this form.

4.  Fully customizeable form --

        function (M, input, success, failure) { ...  }

    `M` is the currently active orchestrator, `input` is the input available at
    the point the action is executed. The most important point to note is this --
    
    > `success` and `failure` are also actions **in this form**.
        
    You'll rarely need this, but this allows you to change orchestrators on the
    fly, start other action sequences using the "current orchestrator",
    whatever that happens to be, tweak the control flow by affecting what comes
    before or after `success` and `failure`, etc. This form permits actions to
    be composed in `IO` and helps separate "what to do" from "when it is being
    done". If you want to trap the full continuations at any point to do
    something strange with them, you can use this form.

## Orchestrators ##

`IO` provides (currently) two ways to run actions --  `IO.run` and `IO.trace`.
These two correspond to the `IO.Ex` and `IO.Tracer` objects called "orchestrators".
Orchestrators are used for customizing the execution pipeline. (Note: This is
still work-in-progress and only some basic functionality is available for
customization.)

1.  `IO.run(input, action)` will run the action normally, passing the given
    input object to it. It is an alias for `IO.Ex`.

        IO.run(input, action) = IO.Ex.run(input, action)

2.  If you want to trace the steps involved as an action runs on `console.log`,
    you can turn an action into a traced action using `IO.trace` like this -
    `IO.trace(action)`. So if you run `IO.run(input, IO.trace(action))`, you'll
    get tracing output on the console. 

        IO.run(input, IO.trace(action)) = IO.Tracer(IO.Ex).run(input, action)

    `IO.trace` works by changing the orchestrator on the fly to a tracer built
    on the original orchestrator used to run the action. The semantics of the
    action aren't affected by the insertion of the trace. This design, as
    opposed to merely exposing the tracer, also lets you trace selected
    portions of a longer action sequence. You can use `IO.trace` as a
    replacement for `IO.do`.


# Core actions #

## IO.do(actions) ##

Makes an action that performs the given actions in the given order, passing
the output of each action to the next. The resulting compound action can be
further composed with other actions.

    IO.do(a1, a2, ...)
    IO.do([a1, a2, ...])

## IO.try(actions, handler) ##

An action that performs the given actions and if any failure occurs, deems
the actions to have failed and passes the error to the handler. The handler
is joined to whatever follows after the try and can therefore continue
by simply succeeding. If the handler fails, the whole try is considered
to fail.

    IO.try(action, handler)
    IO.try([a1, a2, ...], handler)

    IO.try(IO.log("some action"), IO.log("oops! Here is the error - ", true))

## IO.alt(actions) ##

Short for "alternatives". The actions are tried in sequence and the first one
to succeed passes its output to what follows the `IO.alt`.  The whole alt
action is semantically the same as that succeeding action. All actions receive
the same input, unlike `IO.try` where the `handler` receives the error object
of the failed action.

    IO.alt(a1, a2, ...)
    IO.alt([a1, a2, ...])

## IO.raise(info) ##

Raises an in-sequence error meant for handling by whatever handlers have been
setup. The `info` is arbitrary and is just passed along with the error object
in the `error` field. 

    IO.raise("some error object")

## IO.catch(onerror) ##

Sets up a "catch point" for trapping errors raised using `IO.raise`.  This is
useful for implementing commit-rollback semantics. `onerror` is itself an action.

The closest catch point gets to have a go first and can do a variety of things -

1.  Decide that it cannot handle the error and pass on to catch points "higher
    up". To do this, the handler must "fail".

        IO.catch(IO.fail)
        IO.catch(function (err, restart, giveup) {
            // ...
            giveup("some reason, maybe?");
        })

2.  Do something and try the sequence of actions immediately following this
    catch point once more. This is called a "restart". You can even setup loops
    this way. To do this, the handler must "succeed".

        IO.catch(function (err, restart, giveup) {
            // do something
            restart("new input");
        })

        // Ex: This does an infinite restart loop.
        IO.do(IO.log("one")
            , IO.catch(function (err, restart, giveup) {
                  restart("again");
              })
            , IO.log("two")
            , IO.raise("forever"))
        

3.  Take some corrective action and resume from the `raise` point as though it
    succeeded. This "resume" action is available as the "resume" field of the
    error object, which you can call like `error.resume(value)` and the given
    value will be injected there.

        IO.catch(function (err, restart, giveup) {
            // take corrective action here
            err.resume("new input");
        })

        // Ex: 
        IO.do(IO.log("one")
            , IO.log("two")
            , IO.catch(function (err, restart, giveup) {
                err.resume("YAY!");
              })
            , IO.log("three")
            , IO.raise("BOMB!")
            , IO.log("surprise!"))

4.  Do the "rollback" sequence again from the error point. This action is
    available in the error object and is invoked as `error.rollback(value)`.
    The value you pass to the rollback function will usually be the error
    object itself.

        IO.catch(function (err, restart, giveup) {
            // Oh, we figured we can retry!
            err.rollback(err);
        })


5.  Deep customization relative to the error point is available through
    the `success` and `failure` actions stored in the error object. You can
    use this to, for example, change what happens before or after the `resume`
    completes, for example, log an error in a database.

        IO.catch(function (M, err, success, failure) {
            // Note that 'success' and 'failure' are complete
            // actions in themselves and not in the
            // "callback/errback" one-argument style.
            M.call(some_complex_action, err, success, failure);
        })

## IO.finally(cleanup, action) ##

Composes the given `action` with a `cleanup` action such that the cleanup
action will run after action completes successfully or just before action
fails and control is about to leave all steps in action. The `cleanup`
action is passed the same input passed to `action` and the output of the
`cleanup` action is discarded before continuing. 

You want the cleanup action to be as invisible to the surrounding context as
possible, so for semantic purposes `IO.finally(cleanup, action)` would just be
equivalent to `action` as though there is a garbage collector automatically
cleaning up whenever necessary.

## IO.fork(actions, progress) ##

Makes an action that starts off all the actions in the given `actions` array
asynchronously. The resultant action will continue only after *all* of these
actions complete (successfully, or by failing). The results of the actions are
accumulated in an array, which is passed further down the sequence once all the
actions finish. The array will contain either success values or `IO.Error`
objects if errors occurred. 

You can optionally supply a progress function that will be called to be
notified as and when each of the actions complete. The `progress` argument has
to be a function of the form -

    function (i, done, total) {...}

where `i` is the index of the action that completed, `done` is the total
number of actions completed up to the progress call and `total` is the
total actions given. 

    IO.do(IO.log("before")
        , IO.fork([a1, a2, ...])
        , IO.log("after"))

## IO.spawn(action) ##

Spawns off the given action without joining it with the following steps.
`IO.spawn` always succeeds. The errors in the action are not part of the
sequence that the spawn belongs to and won't touch it in any way. 

If you want to fork out some actions but don't want to wait for them to join
back again, do this -

    IO.spawn(IO.fork([a1, a2, ...]))

## IO.timeout(ms, action, onerror) ##

Makes an action that couples the given action with a watchdog timer.  If the
watchdog fires before the action finishes, then the main action sequence will
be considered to fail and the `onerror` action will be run before proceeding to
fail. The input to the `onerror` action is the whole timeout action itself,
passed as a zero-argument function, so that it can be restarted if necessary.
Note that this is a weak timeout, in the sense that the action is not aborted.
Only the continuation is aborted.

## IO.atomic(action) ##

Builds an action that makes the given action operate "atomically".  In other
words, no matter how many action sequences use the resultant atomic action,
there will, at any given time, be at most one running instance of it.  If the
action takes a long time, all those run calls will accumulate at the entry
point of this action and will be processed in sequence one at a time. This is
useful if the intermediate steps contain any "open database -> do something ->
close database" kind of actions.

    IO.atomic(a1, a2, ...)
    IO.atomic([a1, a2, ...])
        = IO.atomic(IO.do(a1, a2, ...))

## IO.dynamic(fn) ##

A dynamic action is an action that is determined by the given function `fn`.
`fn` will be passed the input at the point this action fires and whatever
action `fn` returns will be used as the action to run. 

    IO.dynamic(function (input) {
        return IO.log("some new action");
    })

## IO.cond(branches) ##

A simple kind of dynamic action that chooses from a given list of actions by
pattern matching on the input. `branches` is an array of two-element arrays --
i.e. it is of the form `[[pat1, action1], [pat2, action2], ...]`. The `patN`
are patterns to be matched against the input and if `patK` is the first pattern
that matches, then `actionK` is run as though the whole `cond` was that action
from the beginning. 

If none of the patterns match, `cond` raises an error (the error action is
`IO.cond.error`).  You're supposed to think of all valid cases and support
them. The "raises error" behaviour is there to help you do that. You can
customize this by passing in an action to be used in this case as an extra
argument.

### Patterns ###

Patterns can be -

1.  Simple literals such as string and numbers that are matched against the
    input using `===`. 

        IO.cond([
            //...
            ["literal", IO.log("some action"), ...]
            //...
        ]);

2.  Object literals. In this case, the input must be an object and the keys
    provided must all exist in the input and the values must also pattern
    match. The "patterns" in the value can be, again, of any type in this list.

        IO.cond([
            //...
            [{key1: pat1, key2: pat2, ...}, IO.log("some action"), ...]
            //...
        ]);

3.  A one argument function whose boolean result decides the success of the
    pattern match. Since functions can't usually be meaningfully compared or
    pattern matched against, this is a useful way to provide customizeable
    matching support. `IO.cond.true` is a trivial pattern matcher that always
    succeeds and `IO.cond.false` is one that always fails, which can be used as
    such matchers.

        IO.cond([
            //...
            [function (val) { return val > 3 && val < 10; }, IO.log("some action"), ...]
            //...
        ])


# Trivial but useful actions #

## IO.log(string, inputAlso) ##

An action that logs the string when it is hit and continues normally.
If `inputAlso` is `true`, then the input is also printed using `JSON.stringify`.

    IO.log("hello")

## IO.tap(func) ##

Generates an action that calls `func` with the input that came into the action,
but otherwise doesn't affect the flow and the sequence will automatically
continue. Notice that `func` is not given access to the sequencing object, so
it cannot affect the sequence, not even by throwing an exception.

    IO.tap(function (input) {
        document.write("input received");
    })

## IO.add(input) ##

This generates an action that adds the keys of the supplied input object
to the input that arrived via the action sequence. This is useful for 
inserting additional information into the "data stream".

    IO.run({one: "ek"}, 
        IO.trace(IO.log("before", true)
               , IO.add({two: "do"})
               , IO.log("after", true)));

## IO.supply(input) ##

Similar to `IO.add`, but ignores the input that came in through the
action sequence and replaces it with the given input object.

    IO.run({one: "ek"}, 
        IO.trace(IO.log("before", true)
               , IO.supply({two: "do"})
               , IO.log("after", true)));


## IO.delay(ms, action) ##

Generates an action that will delay the execution of the given action
by the given amount of time. Apart from that, the semantics of the
action doesn't change.

    IO.delay(1000, IO.log("bing!"))

## IO.pass ##

This is a trivial action that you can use as return values from 
functions in case the function wants to return a no-op.

    IO.cond([
        //...
        ["some pat", IO.pass]
        //..
    ])

## IO.fail ##

The trivial fail action jumps to the failure continuation.

    IO.cond([
        //...
        ["some pat", IO.fail]
        //...
    ])

# Utilities #

## IO.util ##

This namespace contains a bunch of utilty functions that make composeable
actions for use elsewhere.

### IO.util.notify(delegate, selector, ...) ###

Calls `delegate[selector](...)` without affecting the flow at this point.
Useful for asynchronous notifications.

## (TODO) IO.browser ##

This namespace contains some utilities for browser-side IO.

### IO.browser.initFileSystemAPI(storageQuota_MB) => fs ###
### IO.browser.fetchURL(url, responseType) => {url: url, data: data} ###
### IO.browser.getFileEntry(fs, absPath) => FileEntry ###
### IO.browser.saveFile(fs, absPath, data) ###
### IO.browser.loadFile(fs, absPath) => {path: absPath, data: result} ###
